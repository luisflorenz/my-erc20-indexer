import {
  require_react
} from "./chunk-RYHZ5DR2.js";
import {
  init_lib3 as init_lib2,
  lib_exports as lib_exports2
} from "./chunk-YSEEYJRV.js";
import {
  init_lib5 as init_lib,
  lib_exports
} from "./chunk-KKGV2QSC.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-J32WSRGE.js";

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl, createStore;
var init_vanilla = __esm({
  "node_modules/zustand/esm/vanilla.mjs"() {
    createStoreImpl = (createState) => {
      let state;
      const listeners = /* @__PURE__ */ new Set();
      const setState = (partial, replace) => {
        const nextState = typeof partial === "function" ? partial(state) : partial;
        if (!Object.is(nextState, state)) {
          const previousState = state;
          state = (replace != null ? replace : typeof nextState !== "object") ? nextState : Object.assign({}, state, nextState);
          listeners.forEach((listener) => listener(state, previousState));
        }
      };
      const getState = () => state;
      const subscribe = (listener) => {
        listeners.add(listener);
        return () => listeners.delete(listener);
      };
      const destroy = () => {
        if ((import.meta.env ? import.meta.env.MODE : void 0) !== "production") {
          console.warn(
            "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
          );
        }
        listeners.clear();
      };
      const api = { setState, getState, subscribe, destroy };
      state = createState(setState, getState, api);
      return api;
    };
    createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format) {
          {
            {
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              printWarning("error", format, args);
            }
          }
        }
        function printWarning(level, format, args) {
          {
            var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame.getStackAddendum();
            if (stack !== "") {
              format += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return String(item);
            });
            argsWithFormat.unshift("Warning: " + format);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue3 = React.useDebugValue;
        var didWarnOld18Alpha = false;
        var didWarnUncachedGetSnapshot = false;
        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
          {
            if (!didWarnOld18Alpha) {
              if (React.startTransition !== void 0) {
                didWarnOld18Alpha = true;
                error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
              }
            }
          }
          var value = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedValue = getSnapshot();
              if (!objectIs(value, cachedValue)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var _useState = useState({
            inst: {
              value,
              getSnapshot
            }
          }), inst = _useState[0].inst, forceUpdate = _useState[1];
          useLayoutEffect(function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          }, [subscribe, value, getSnapshot]);
          useEffect(function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            };
            return subscribe(handleStoreChange);
          }, [subscribe]);
          useDebugValue3(value);
          return value;
        }
        function checkIfSnapshotChanged(inst) {
          var latestGetSnapshot = inst.getSnapshot;
          var prevValue = inst.value;
          try {
            var nextValue = latestGetSnapshot();
            return !objectIs(prevValue, nextValue);
          } catch (error2) {
            return true;
          }
        }
        function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
          return getSnapshot();
        }
        var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
        var isServerEnvironment = !canUseDOM;
        var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
        var useSyncExternalStore$2 = React.useSyncExternalStore !== void 0 ? React.useSyncExternalStore : shim;
        exports.useSyncExternalStore = useSyncExternalStore$2;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
        }
        var React = require_react();
        var shim = require_shim();
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var useSyncExternalStore = shim.useSyncExternalStore;
        var useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue3 = React.useDebugValue;
        function useSyncExternalStoreWithSelector3(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
          var instRef = useRef(null);
          var inst;
          if (instRef.current === null) {
            inst = {
              hasValue: false,
              value: null
            };
            instRef.current = inst;
          } else {
            inst = instRef.current;
          }
          var _useMemo = useMemo(function() {
            var hasMemo = false;
            var memoizedSnapshot;
            var memoizedSelection;
            var memoizedSelector = function(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                var _nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0) {
                  if (inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, _nextSelection)) {
                      memoizedSelection = currentSelection;
                      return currentSelection;
                    }
                  }
                }
                memoizedSelection = _nextSelection;
                return _nextSelection;
              }
              var prevSnapshot = memoizedSnapshot;
              var prevSelection = memoizedSelection;
              if (objectIs(prevSnapshot, nextSnapshot)) {
                return prevSelection;
              }
              var nextSelection = selector(nextSnapshot);
              if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                return prevSelection;
              }
              memoizedSnapshot = nextSnapshot;
              memoizedSelection = nextSelection;
              return nextSelection;
            };
            var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
            var getSnapshotWithSelector = function() {
              return memoizedSelector(getSnapshot());
            };
            var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
              return memoizedSelector(maybeGetServerSnapshot());
            };
            return [getSnapshotWithSelector, getServerSnapshotWithSelector];
          }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
          var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
          useEffect(function() {
            inst.hasValue = true;
            inst.value = value;
          }, [value]);
          useDebugValue3(value);
          return value;
        }
        exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector3;
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
        }
      })();
    }
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/zustand/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  create: () => create,
  createStore: () => createStore,
  default: () => react,
  useStore: () => useStore
});
function useStore(api, selector = api.getState, equalityFn) {
  if (equalityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  (0, import_react.useDebugValue)(slice);
  return slice;
}
var import_react, import_with_selector, useSyncExternalStoreWithSelector, createImpl, create, react;
var init_esm = __esm({
  "node_modules/zustand/esm/index.js"() {
    init_vanilla();
    init_vanilla();
    import_react = __toESM(require_react());
    import_with_selector = __toESM(require_with_selector());
    ({ useSyncExternalStoreWithSelector } = import_with_selector.default);
    createImpl = (createState) => {
      if (typeof createState !== "function") {
        console.warn(
          "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
        );
      }
      const api = typeof createState === "function" ? createStore(createState) : createState;
      const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
      Object.assign(useBoundStore, api);
      return useBoundStore;
    };
    create = (createState) => createState ? createImpl(createState) : createImpl;
    react = (createState) => {
      if (true) {
        console.warn(
          "[DEPRECATED] Default export is deprecated. Instead use `import { create } from 'zustand'`."
        );
      }
      return create(createState);
    };
  }
});

// node_modules/@web3-react/store/dist/index.js
var require_dist = __commonJS({
  "node_modules/@web3-react/store/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createWeb3ReactStoreAndActions = exports.MAX_SAFE_CHAIN_ID = void 0;
    var address_1 = (init_lib(), __toCommonJS(lib_exports));
    var zustand_1 = (init_esm(), __toCommonJS(esm_exports));
    exports.MAX_SAFE_CHAIN_ID = 4503599627370476;
    function validateChainId(chainId) {
      if (!Number.isInteger(chainId) || chainId <= 0 || chainId > exports.MAX_SAFE_CHAIN_ID) {
        throw new Error(`Invalid chainId ${chainId}`);
      }
    }
    function validateAccount(account) {
      return (0, address_1.getAddress)(account);
    }
    var DEFAULT_STATE = {
      chainId: void 0,
      accounts: void 0,
      activating: false
    };
    function createWeb3ReactStoreAndActions() {
      const store = (0, zustand_1.createStore)()(() => DEFAULT_STATE);
      let nullifier = 0;
      function startActivation() {
        const nullifierCached = ++nullifier;
        store.setState(Object.assign(Object.assign({}, DEFAULT_STATE), { activating: true }));
        return () => {
          if (nullifier === nullifierCached)
            store.setState({ activating: false });
        };
      }
      function update(stateUpdate) {
        if (stateUpdate.chainId !== void 0) {
          validateChainId(stateUpdate.chainId);
        }
        if (stateUpdate.accounts !== void 0) {
          for (let i = 0; i < stateUpdate.accounts.length; i++) {
            stateUpdate.accounts[i] = validateAccount(stateUpdate.accounts[i]);
          }
        }
        nullifier++;
        store.setState((existingState) => {
          var _a, _b;
          const chainId = (_a = stateUpdate.chainId) !== null && _a !== void 0 ? _a : existingState.chainId;
          const accounts = (_b = stateUpdate.accounts) !== null && _b !== void 0 ? _b : existingState.accounts;
          let activating = existingState.activating;
          if (activating && chainId && accounts) {
            activating = false;
          }
          return { chainId, accounts, activating };
        });
      }
      function resetState() {
        nullifier++;
        store.setState(DEFAULT_STATE);
      }
      return [store, { startActivation, update, resetState }];
    }
    exports.createWeb3ReactStoreAndActions = createWeb3ReactStoreAndActions;
  }
});

// node_modules/zustand/esm/traditional.js
var traditional_exports = {};
__export(traditional_exports, {
  createWithEqualityFn: () => createWithEqualityFn,
  useStoreWithEqualityFn: () => useStoreWithEqualityFn
});
function useStoreWithEqualityFn(api, selector = api.getState, equalityFn) {
  const slice = useSyncExternalStoreWithSelector2(
    api.subscribe,
    api.getState,
    api.getServerState || api.getState,
    selector,
    equalityFn
  );
  (0, import_react2.useDebugValue)(slice);
  return slice;
}
var import_react2, import_with_selector2, useSyncExternalStoreWithSelector2, createWithEqualityFnImpl, createWithEqualityFn;
var init_traditional = __esm({
  "node_modules/zustand/esm/traditional.js"() {
    import_react2 = __toESM(require_react());
    import_with_selector2 = __toESM(require_with_selector());
    init_vanilla();
    ({ useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector2 } = import_with_selector2.default);
    createWithEqualityFnImpl = (createState, defaultEqualityFn) => {
      const api = createStore(createState);
      const useBoundStoreWithEqualityFn = (selector, equalityFn = defaultEqualityFn) => useStoreWithEqualityFn(api, selector, equalityFn);
      Object.assign(useBoundStoreWithEqualityFn, api);
      return useBoundStoreWithEqualityFn;
    };
    createWithEqualityFn = (createState, defaultEqualityFn) => createState ? createWithEqualityFnImpl(createState, defaultEqualityFn) : createWithEqualityFnImpl;
  }
});

// node_modules/@web3-react/core/dist/hooks.js
var require_hooks = __commonJS({
  "node_modules/@web3-react/core/dist/hooks.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPriorityConnector = exports.getSelectedConnector = exports.initializeConnector = void 0;
    var store_1 = require_dist();
    var react_1 = require_react();
    var zustand_1 = (init_esm(), __toCommonJS(esm_exports));
    var traditional_1 = (init_traditional(), __toCommonJS(traditional_exports));
    var DynamicProvider;
    function importProvider() {
      return __awaiter(this, void 0, void 0, function* () {
        if (DynamicProvider === void 0) {
          try {
            const { Web3Provider } = yield Promise.resolve().then(() => __importStar((init_lib2(), __toCommonJS(lib_exports2))));
            DynamicProvider = Web3Provider;
          } catch (_a) {
            console.debug("@ethersproject/providers not available");
            DynamicProvider = null;
          }
        }
      });
    }
    function initializeConnector(f) {
      const [store, actions] = (0, store_1.createWeb3ReactStoreAndActions)();
      const connector = f(actions);
      const stateHooks = getStateHooks(store);
      const derivedHooks = getDerivedHooks(stateHooks);
      const augmentedHooks = getAugmentedHooks(connector, stateHooks, derivedHooks);
      return [connector, Object.assign(Object.assign(Object.assign({}, stateHooks), derivedHooks), augmentedHooks), store];
    }
    exports.initializeConnector = initializeConnector;
    function computeIsActive({ chainId, accounts, activating }) {
      return Boolean(chainId && accounts && !activating);
    }
    function getSelectedConnector(...initializedConnectors) {
      function getIndex(connector) {
        const index = initializedConnectors.findIndex(([initializedConnector]) => connector === initializedConnector);
        if (index === -1)
          throw new Error("Connector not found");
        return index;
      }
      function useSelectedStore(connector) {
        const store = initializedConnectors[getIndex(connector)][2];
        if (!store)
          throw new Error("Stores not passed");
        return store;
      }
      function useSelectedChainId(connector) {
        const values = initializedConnectors.map(([, { useChainId }]) => useChainId());
        return values[getIndex(connector)];
      }
      function useSelectedAccounts(connector) {
        const values = initializedConnectors.map(([, { useAccounts }]) => useAccounts());
        return values[getIndex(connector)];
      }
      function useSelectedIsActivating(connector) {
        const values = initializedConnectors.map(([, { useIsActivating }]) => useIsActivating());
        return values[getIndex(connector)];
      }
      function useSelectedAccount(connector) {
        const values = initializedConnectors.map(([, { useAccount }]) => useAccount());
        return values[getIndex(connector)];
      }
      function useSelectedIsActive(connector) {
        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());
        return values[getIndex(connector)];
      }
      function useSelectedProvider(connector, network) {
        const index = getIndex(connector);
        const values = initializedConnectors.map(([, { useProvider }], i) => useProvider(network, i === index));
        return values[index];
      }
      function useSelectedENSNames(connector, provider) {
        const index = getIndex(connector);
        const values = initializedConnectors.map(([, { useENSNames }], i) => (
          // eslint-disable-next-line react-hooks/rules-of-hooks
          useENSNames(i === index ? provider : void 0)
        ));
        return values[index];
      }
      function useSelectedENSName(connector, provider) {
        const index = getIndex(connector);
        const values = initializedConnectors.map(([, { useENSName }], i) => useENSName(i === index ? provider : void 0));
        return values[index];
      }
      return {
        useSelectedStore,
        useSelectedChainId,
        useSelectedAccounts,
        useSelectedIsActivating,
        useSelectedAccount,
        useSelectedIsActive,
        useSelectedProvider,
        useSelectedENSNames,
        useSelectedENSName
      };
    }
    exports.getSelectedConnector = getSelectedConnector;
    function getPriorityConnector(...initializedConnectors) {
      const { useSelectedStore, useSelectedChainId, useSelectedAccounts, useSelectedIsActivating, useSelectedAccount, useSelectedIsActive, useSelectedProvider, useSelectedENSNames, useSelectedENSName } = getSelectedConnector(...initializedConnectors);
      function usePriorityConnector() {
        const values = initializedConnectors.map(([, { useIsActive }]) => useIsActive());
        const index = values.findIndex((isActive) => isActive);
        return initializedConnectors[index === -1 ? 0 : index][0];
      }
      function usePriorityStore() {
        return useSelectedStore(usePriorityConnector());
      }
      function usePriorityChainId() {
        return useSelectedChainId(usePriorityConnector());
      }
      function usePriorityAccounts() {
        return useSelectedAccounts(usePriorityConnector());
      }
      function usePriorityIsActivating() {
        return useSelectedIsActivating(usePriorityConnector());
      }
      function usePriorityAccount() {
        return useSelectedAccount(usePriorityConnector());
      }
      function usePriorityIsActive() {
        return useSelectedIsActive(usePriorityConnector());
      }
      function usePriorityProvider(network) {
        return useSelectedProvider(usePriorityConnector(), network);
      }
      function usePriorityENSNames(provider) {
        return useSelectedENSNames(usePriorityConnector(), provider);
      }
      function usePriorityENSName(provider) {
        return useSelectedENSName(usePriorityConnector(), provider);
      }
      return {
        useSelectedStore,
        useSelectedChainId,
        useSelectedAccounts,
        useSelectedIsActivating,
        useSelectedAccount,
        useSelectedIsActive,
        useSelectedProvider,
        useSelectedENSNames,
        useSelectedENSName,
        usePriorityConnector,
        usePriorityStore,
        usePriorityChainId,
        usePriorityAccounts,
        usePriorityIsActivating,
        usePriorityAccount,
        usePriorityIsActive,
        usePriorityProvider,
        usePriorityENSNames,
        usePriorityENSName
      };
    }
    exports.getPriorityConnector = getPriorityConnector;
    var CHAIN_ID = ({ chainId }) => chainId;
    var ACCOUNTS = ({ accounts }) => accounts;
    var ACTIVATING = ({ activating }) => activating;
    var ACCOUNTS_EQUALITY_CHECKER = (oldAccounts, newAccounts) => oldAccounts === void 0 && newAccounts === void 0 || oldAccounts !== void 0 && oldAccounts.length === (newAccounts === null || newAccounts === void 0 ? void 0 : newAccounts.length) && oldAccounts.every((oldAccount, i) => oldAccount === newAccounts[i]);
    function getStateHooks(store) {
      function useChainId() {
        return (0, zustand_1.useStore)(store, CHAIN_ID);
      }
      function useAccounts() {
        return (0, traditional_1.useStoreWithEqualityFn)(store, ACCOUNTS, ACCOUNTS_EQUALITY_CHECKER);
      }
      function useIsActivating() {
        return (0, zustand_1.useStore)(store, ACTIVATING);
      }
      return { useChainId, useAccounts, useIsActivating };
    }
    function getDerivedHooks({ useChainId, useAccounts, useIsActivating }) {
      function useAccount() {
        var _a;
        return (_a = useAccounts()) === null || _a === void 0 ? void 0 : _a[0];
      }
      function useIsActive() {
        const chainId = useChainId();
        const accounts = useAccounts();
        const activating = useIsActivating();
        return computeIsActive({
          chainId,
          accounts,
          activating
        });
      }
      return { useAccount, useIsActive };
    }
    function useENS(provider, accounts = []) {
      const [ENSNames, setENSNames] = (0, react_1.useState)();
      (0, react_1.useEffect)(() => {
        if (provider && accounts.length) {
          let stale = false;
          Promise.all(accounts.map((account) => provider.lookupAddress(account))).then((ENSNames2) => {
            if (stale)
              return;
            setENSNames(ENSNames2);
          }).catch((error) => {
            if (stale)
              return;
            console.debug("Could not fetch ENS names", error);
            setENSNames(new Array(accounts.length).fill(null));
          });
          return () => {
            stale = true;
            setENSNames(void 0);
          };
        }
      }, [provider, accounts]);
      return ENSNames !== null && ENSNames !== void 0 ? ENSNames : new Array(accounts.length).fill(void 0);
    }
    function getAugmentedHooks(connector, { useAccounts, useChainId }, { useAccount, useIsActive }) {
      function useProvider(network, enabled = true) {
        const isActive = useIsActive();
        const chainId = useChainId();
        const [loaded, setLoaded] = (0, react_1.useState)(DynamicProvider !== void 0);
        (0, react_1.useEffect)(() => {
          if (loaded)
            return;
          let stale = false;
          void importProvider().then(() => {
            if (stale)
              return;
            setLoaded(true);
          });
          return () => {
            stale = true;
          };
        }, [loaded]);
        return (0, react_1.useMemo)(() => {
          if (enabled) {
            if (connector.customProvider)
              return connector.customProvider;
            else if (DynamicProvider && connector.provider)
              return new DynamicProvider(connector.provider, network);
          }
        }, [loaded, enabled, isActive, chainId, network]);
      }
      function useENSNames(provider) {
        const accounts = useAccounts();
        return useENS(provider, accounts);
      }
      function useENSName(provider) {
        var _a;
        const account = useAccount();
        const accounts = (0, react_1.useMemo)(() => account === void 0 ? void 0 : [account], [account]);
        return (_a = useENS(provider, accounts)) === null || _a === void 0 ? void 0 : _a[0];
      }
      return { useProvider, useENSNames, useENSName };
    }
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;
    EventEmitter.prefixed = prefix;
    EventEmitter.EventEmitter = EventEmitter;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter;
    }
  }
});

// node_modules/@web3-react/core/dist/mocks.js
var require_mocks = __commonJS({
  "node_modules/@web3-react/core/dist/mocks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MockEIP1193Provider = void 0;
    var eventemitter3_1 = require_eventemitter3();
    var MockEIP1193Provider = class extends eventemitter3_1.EventEmitter {
      constructor() {
        super(...arguments);
        this.eth_chainId = jest.fn((chainId) => chainId);
        this.eth_accounts = jest.fn((accounts) => accounts);
        this.eth_requestAccounts = jest.fn((accounts) => accounts);
      }
      request(x) {
        if (!this.chainId)
          return Promise.reject(new Error());
        switch (x.method) {
          case "eth_chainId":
            return Promise.resolve(this.eth_chainId(this.chainId));
          case "eth_accounts":
            return Promise.resolve(this.eth_accounts(this.accounts));
          case "eth_requestAccounts":
            return Promise.resolve(this.eth_requestAccounts(this.accounts));
          default:
            throw new Error(`Method not supported on mock: ${JSON.stringify(x)}`);
        }
      }
      emitConnect(chainId) {
        this.emit("connect", { chainId });
      }
      emitDisconnect(error) {
        this.emit("disconnect", error);
      }
      emitChainChanged(chainId) {
        this.emit("chainChanged", chainId);
      }
      emitAccountsChanged(accounts) {
        this.emit("accountsChanged", accounts);
      }
    };
    exports.MockEIP1193Provider = MockEIP1193Provider;
  }
});

// node_modules/@web3-react/core/dist/provider.js
var require_provider = __commonJS({
  "node_modules/@web3-react/core/dist/provider.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWeb3React = exports.Web3ReactProvider = void 0;
    var react_1 = __importStar(require_react());
    var hooks_1 = require_hooks();
    var Web3Context = (0, react_1.createContext)(void 0);
    function Web3ReactProvider({ children, connectors, connectorOverride, network, lookupENS = true }) {
      const cachedConnectors = (0, react_1.useRef)(connectors);
      if (connectors.length != cachedConnectors.current.length || connectors.some((connector2, i) => {
        const cachedConnector = cachedConnectors.current[i];
        return connector2[0] !== cachedConnector[0];
      }))
        throw new Error("The connectors prop passed to Web3ReactProvider must be referentially static. If connectors is changing, try providing a key prop to Web3ReactProvider that changes every time connectors changes.");
      const hooks = (0, hooks_1.getPriorityConnector)(...connectors);
      const { usePriorityConnector, useSelectedChainId, useSelectedAccounts, useSelectedIsActivating, useSelectedAccount, useSelectedIsActive, useSelectedProvider, useSelectedENSNames, useSelectedENSName } = hooks;
      const priorityConnector = usePriorityConnector();
      const connector = connectorOverride !== null && connectorOverride !== void 0 ? connectorOverride : priorityConnector;
      const chainId = useSelectedChainId(connector);
      const accounts = useSelectedAccounts(connector);
      const isActivating = useSelectedIsActivating(connector);
      const account = useSelectedAccount(connector);
      const isActive = useSelectedIsActive(connector);
      const provider = useSelectedProvider(connector, network);
      const ENSNames = useSelectedENSNames(connector, lookupENS ? provider : void 0);
      const ENSName = useSelectedENSName(connector, lookupENS ? provider : void 0);
      return react_1.default.createElement(Web3Context.Provider, { value: {
        connector,
        chainId,
        accounts,
        isActivating,
        account,
        isActive,
        provider,
        ENSNames,
        ENSName,
        hooks
      } }, children);
    }
    exports.Web3ReactProvider = Web3ReactProvider;
    function useWeb3React() {
      const context = (0, react_1.useContext)(Web3Context);
      if (!context)
        throw Error("useWeb3React can only be used within the Web3ReactProvider component");
      return context;
    }
    exports.useWeb3React = useWeb3React;
  }
});

// node_modules/@web3-react/core/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@web3-react/core/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_hooks(), exports);
    __exportStar(require_mocks(), exports);
    __exportStar(require_provider(), exports);
  }
});
export default require_dist2();
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@web3-react_core.js.map
