import {
  JsonRpcProvider,
  fetchJson,
  getNetwork,
  init_lib as init_lib3,
  init_lib2 as init_lib4,
  init_lib3 as init_lib5
} from "./chunk-YSEEYJRV.js";
import {
  CustomNetworks,
  DEFAULT_ALCHEMY_API_KEY,
  DEFAULT_NETWORK,
  EthersNetwork,
  IS_BROWSER,
  Network,
  VERSION,
  __awaiter$1,
  deepCopy,
  getAlchemyHttpUrl,
  getAlchemyWsUrl,
  logWarn,
  require_axios
} from "./chunk-M6QQ7V5Q.js";
import {
  init_lib3 as init_lib,
  init_lib7 as init_lib2
} from "./chunk-KKGV2QSC.js";
import {
  __toESM
} from "./chunk-J32WSRGE.js";

// node_modules/alchemy-sdk/dist/esm/alchemy-provider-8993bb18.js
init_lib3();
init_lib5();
init_lib4();
init_lib();
var import_axios = __toESM(require_axios());
init_lib2();
var DEFAULT_MAX_REQUEST_BATCH_SIZE = 100;
var DEFAULT_REQUEST_BATCH_DELAY_MS = 10;
var RequestBatcher = class {
  constructor(sendBatchFn, maxBatchSize = DEFAULT_MAX_REQUEST_BATCH_SIZE) {
    this.sendBatchFn = sendBatchFn;
    this.maxBatchSize = maxBatchSize;
    this.pendingBatch = [];
  }
  /**
   * Enqueues the provided request. The batch is immediately sent if the maximum
   * batch size is reached. Otherwise, the request is enqueued onto a batch that
   * is sent after 10ms.
   *
   * Returns a promise that resolves with the result of the request.
   */
  enqueueRequest(request) {
    return __awaiter$1(this, void 0, void 0, function* () {
      const inflightRequest = {
        request,
        resolve: void 0,
        reject: void 0
      };
      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });
      this.pendingBatch.push(inflightRequest);
      if (this.pendingBatch.length === this.maxBatchSize) {
        void this.sendBatchRequest();
      } else if (!this.pendingBatchTimer) {
        this.pendingBatchTimer = setTimeout(() => this.sendBatchRequest(), DEFAULT_REQUEST_BATCH_DELAY_MS);
      }
      return promise;
    });
  }
  /**
   * Sends the currently queued batches and resets the batch and timer. Processes
   * the batched response results back to the original promises.
   */
  sendBatchRequest() {
    return __awaiter$1(this, void 0, void 0, function* () {
      const batch = this.pendingBatch;
      this.pendingBatch = [];
      if (this.pendingBatchTimer) {
        clearTimeout(this.pendingBatchTimer);
        this.pendingBatchTimer = void 0;
      }
      const request = batch.map((inflight) => inflight.request);
      return this.sendBatchFn(request).then((result) => {
        batch.forEach((inflightRequest, index) => {
          const payload = result[index];
          if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            inflightRequest.reject(error);
          } else {
            inflightRequest.resolve(payload.result);
          }
        });
      }, (error) => {
        batch.forEach((inflightRequest) => {
          inflightRequest.reject(error);
        });
      });
    });
  }
};
var AlchemyProvider = class _AlchemyProvider extends JsonRpcProvider {
  /** @internal */
  constructor(config) {
    const apiKey = _AlchemyProvider.getApiKey(config.apiKey);
    const alchemyNetwork = _AlchemyProvider.getAlchemyNetwork(config.network);
    const connection = _AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, "http");
    if (config.url !== void 0) {
      connection.url = config.url;
    }
    connection.throttleLimit = config.maxRetries;
    const ethersNetwork = EthersNetwork[alchemyNetwork];
    super(connection, ethersNetwork);
    this.apiKey = config.apiKey;
    this.maxRetries = config.maxRetries;
    this.batchRequests = config.batchRequests;
    const batcherConnection = Object.assign(Object.assign({}, this.connection), { headers: Object.assign(Object.assign({}, this.connection.headers), { "Alchemy-Ethers-Sdk-Method": "batchSend" }) });
    const sendBatchFn = (requests) => {
      return fetchJson(batcherConnection, JSON.stringify(requests));
    };
    this.batcher = new RequestBatcher(sendBatchFn);
    this.modifyFormatter();
  }
  /**
   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by
   * ethers.js. Returns the API key for an Alchemy provider.
   *
   * @internal
   * @override
   */
  static getApiKey(apiKey) {
    if (apiKey == null) {
      return DEFAULT_ALCHEMY_API_KEY;
    }
    if (apiKey && typeof apiKey !== "string") {
      throw new Error(`Invalid apiKey '${apiKey}' provided. apiKey must be a string.`);
    }
    return apiKey;
  }
  /**
   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.
   *
   * This override allows the SDK to set the provider's network to values not
   * yet supported by ethers.js.
   *
   * @internal
   * @override
   */
  static getNetwork(network) {
    if (typeof network === "string" && network in CustomNetworks) {
      return CustomNetworks[network];
    }
    return getNetwork(network);
  }
  /**
   * Converts the `Networkish` input to the network enum used by Alchemy.
   *
   * @internal
   */
  static getAlchemyNetwork(network) {
    if (network === void 0) {
      return DEFAULT_NETWORK;
    }
    if (typeof network === "number") {
      throw new Error(`Invalid network '${network}' provided. Network must be a string.`);
    }
    const isValidNetwork = Object.values(Network).includes(network);
    if (!isValidNetwork) {
      throw new Error(`Invalid network '${network}' provided. Network must be one of: ${Object.values(Network).join(", ")}.`);
    }
    return network;
  }
  /**
   * Returns a {@link ConnectionInfo} object compatible with ethers that contains
   * the correct URLs for Alchemy.
   *
   * @internal
   */
  static getAlchemyConnectionInfo(network, apiKey, type) {
    const url = type === "http" ? getAlchemyHttpUrl(network, apiKey) : getAlchemyWsUrl(network, apiKey);
    return {
      headers: IS_BROWSER ? {
        "Alchemy-Ethers-Sdk-Version": VERSION
      } : {
        "Alchemy-Ethers-Sdk-Version": VERSION,
        "Accept-Encoding": "gzip"
      },
      allowGzip: true,
      url
    };
  }
  /**
   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This
   * method is called when calling methods on the parent class `BaseProvider`.
   *
   * @override
   */
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: { get: () => super.detectNetwork }
    });
    return __awaiter$1(this, void 0, void 0, function* () {
      let network = this.network;
      if (network == null) {
        network = yield _super.detectNetwork.call(this);
        if (!network) {
          throw new Error("No network detected");
        }
      }
      return network;
    });
  }
  _startPending() {
    logWarn("WARNING: Alchemy Provider does not support pending filters");
  }
  /**
   * Overrides the ether's `isCommunityResource()` method. Returns true if the
   * current api key is the default key.
   *
   * @override
   */
  isCommunityResource() {
    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;
  }
  /**
   * Overrides the base {@link JsonRpcProvider.send} method to implement custom
   * logic for sending requests to Alchemy.
   *
   * @param method The method name to use for the request.
   * @param params The parameters to use for the request.
   * @override
   * @public
   */
  // TODO: Add headers for `perform()` override.
  send(method, params) {
    return this._send(method, params, "send");
  }
  /**
   * DO NOT MODIFY.
   *
   * Original code copied over from ether.js's `JsonRpcProvider.send()`.
   *
   * This method is copied over directly in order to implement custom headers
   *
   * @internal
   */
  _send(method, params, methodName, forceBatch = false) {
    const request = {
      method,
      params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    const connection = Object.assign({}, this.connection);
    connection.headers["Alchemy-Ethers-Sdk-Method"] = methodName;
    if (this.batchRequests || forceBatch) {
      return this.batcher.enqueueRequest(request);
    }
    this.emit("debug", {
      action: "request",
      request: deepCopy(request),
      provider: this
    });
    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
    if (cache && this._cache[method]) {
      return this._cache[method];
    }
    const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
      this.emit("debug", {
        action: "response",
        request,
        response: result2,
        provider: this
      });
      return result2;
    }, (error) => {
      this.emit("debug", {
        action: "response",
        error,
        request,
        provider: this
      });
      throw error;
    });
    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }
    return result;
  }
  /**
   * Overrides the base `Formatter` class inherited from ethers to support
   * returning custom fields in Ethers response types.
   *
   * For context, ethers has a `Formatter` class that is used to format the
   * response from a JSON-RPC request. Any fields that are not defined in the
   * `Formatter` class are removed from the returned response. By modifying the
   * `Formatter` class in this method, we can add support for fields that are
   * not defined in ethers.
   */
  modifyFormatter() {
    this.formatter.formats["receiptLog"]["removed"] = (val) => {
      if (typeof val === "boolean") {
        return val;
      }
      return void 0;
    };
  }
};
function getResult(payload) {
  if (payload.error) {
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }
  return payload.result;
}

export {
  AlchemyProvider
};
//# sourceMappingURL=chunk-73JH2RO3.js.map
